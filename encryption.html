<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>加密页面</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">加密页面</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="密码"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解密" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02988fda45d424fad1fb2bf4d41a5718cd5ccebcc6820ed6889404c77e008f34d7f23e56a29fbe722482cc1853f9953e04b7b01259e9dadffbb9ce03481213cf4d2e26f116273d9c2d6daad034dea29d7e3319d52c708eeff1bb30c8501bd7e73f083257de45df1b1cefd30606d536f81926cebbb252ad28b6b4c73f7667c71ae93711632dbeb3947912550bb3eae627c682054bfa0841e8cdef3bbc077244be4d05b99747fd0ea5fdb3f639a130f4b3d14388a758a7286a4ab3c46c9ebc2ee18c61849d26912c68d7c56daa21e01fba2223711e442a5cd6021495ee8854fc013d19f32d9284b9c7ef95ca2a4e8ea7388cc884ee55deb2ec1d8067d51af2b20700866c7b505ad2551b84fda57b69a6f4422897a8b70191b1b51c02c4c43c7304d0a22086589f820f0fda0a378fe85df52143636ea5a685698118e03516f2d7f44d30359535242e8f383d0593325e46f07f865ee862e15b8c5e36eea51679dc28765c4ae7823c763fbf2a9f25296077476217f206070a93957b98583c765f3d354779f64ae7d0d96f3c58d78de256de78784e9c135932718e9cb333e67632fc1e8f675331a983f4fc247e02bdab05a0ea39dbe9b1edbacee66e253cfc6a4704996a4a0a29dcbc7e8abf37b9880d991a6ceafd9ba40c17cee415defbd7d0fcbbf5175084b7459993b7ea752119c3f5398dc038dbb32f2115abba8f66a96f5a4faf3f5189751f235f3105b629b0c8929b45848974d26951bf7f5dd32e53eadd808ae5fe0f80bef7ee44e634273e09dc4117637059f561ce4d753a1be3dc5b339964138710b5e6adcf390ff38229c2ac66005687f9826e870dc88a78c0b986b98325b348d3fd50be01e26208acfaefc9eed32fbc4f0b163a033e5673a8a69106e36d08eda942f6046e9a0b299e10918a59e30b9a0885b6f7bedfee9b7a1070d73784afd786fd563dae713f97b3c053140a04b8a145d3e50a898c085428a4e254865b00301152dd3f9b0b66ffd9f2f491d009ca4e01c34a83dc21ac02b36cc93fef1a67bac71bf5aacd47fa40ad81183dd4e4a71de7f4ad286c3fa5850b40c8afcd0e1418434815f61bb609b9a1d660ddd8bdaccbb04454dfd7d9233c93835726b4e6f097b86f65751cc66a7cc13a7e66c04fb84792f628873b48f40a06c06267f0e06101084a22dd3365ea006e1b07e545fbb516fcc6c3f2195b3bc3ebe3e4f5a421257f76d0f2b68b8ee43a1cf780c6ab22fe4f5399d70e89ca8e4f96bd6be5e742db6212dde354b457fd5eea439664405e7a6c51cbb160f6d4b0f530663f2667d7da850dad383dd91bc26e7fce596914e033a63f8ffd46dcde5a71750b576d389569ffcfdf6604d5aeacae7792b4a659131b0da37b8aeea42332a08e1ce7d4f033f3cefaa2fac22f1b6071ee994e1a9ce3a34fd6cc713581252b0e558f050b78da995a7eafd4f79ac0b89a6c9691ec6d65d0da68227802bb71960d53df56e89c44c2995d36137f503315a2aa2eef22819690dbadce19a5511d588e8c216a92d09430befed92bd54e514d20f2db74e63fb319743e88a01c1b12e387e8886f97df0975c8a27a07e9730d3e1163f0823ed9412edbf6e3df4c20dbde5fadf3ca8aa45b32fdfa83c07be1940bd210257a991343b16a64dc0cac71b5eb09b0a83a66dec5653f8b519a86e7c2241b255dfbf92772a3f5d9cdb84d04200bd0ecbfe0e400943eb10f5b4f063e214046910f0237db8050f98bc9e075b5b823fe20b9cd36f6aa71c6590883259fadda1dd2c8c9683cd6a54c546e80ce36364eb8422fec8b0459bdf6b056d894653636903ac71b8425277dc2b6e248e7056f5767af918c9ec2725f2931228c8ab707b551ac7feb01ddf8b2db8877901a8e22789d3c0661f313ec96d73ba33b97d1ec626f1b708403c6f93f2297bae2a1def06b184d22d4a633b746841a23dd61a69723337c6f72972c43af499674d93ed60d350e0f008ab6b83d71d6c519fc4cb31dc05d7ca210e673ac1f0058bc64b11f7207d9c435a93adec2577829284871ee28596a30f7bc31a6d1150131b9a71bc3029d60e14a68512e55f4e040f417376b24aa61b68469fa3beaad3b1b52aae16d70f3dfbc32705044623f24f27867419ea7a6ae3e8a1b3bb07eade5e0ffbbe5b11ab8790ceecf58c1658da353b414d3cf381514b677deee1dae7d6ef2ff4e3838f6a10e709031583a02c4e156ee50c1546fad51258ad4a22ce06d8e22a5996c1e3ec0ebc7ab234b8419c7a75ef323e389d9165bb33111abac109f04abdfa6f5efc9ed089dde9d33b8b07ef287e3220853112eb61c3baf1aa1953df687273dfb42a67461156221d79e7efd4cc4a7c02ce50b7fb514839387b96230e86fe6d0c4fa69b9ab5b4c7af5feb6ab268e34c569b671cd3d680d9ceee0fc5a829f38da6a62373cd41e64d5c2e23fcc1fb5de45ed2cbfef8c59171f04102ac20961456abd254c0bb3c72412dae56ae17819fc3b567a4dd5147a103826f2f1302f205854468072b7f49a07ee4aa99daf588d836a3efb3b3f380793d3cbda5bb1e3733fba8a1ed2167455ac64baa890395979620d4ce7a7b981ef8410034d02dfae169b03c38336bcca06033c9de024f68a5f2a7612aa95c2bbe401a9754642976e4fd3cc092a7f0659615484fa766cf691f0566289876978daac7702de257216899d10f8b4c96c43738a3f3711843a906b3b68d3e01d83d02497cdf15b692edf39a11d0dbda6efaf413b29b10394fdca663832dd724dacdc10218361e99ab3c6b7234cfb1efd19dd2a49e12ae4a49017de8737cb87478472c3b8404027644f73b5ef2a518266d80b1ec4d2d69bdaa82f24e528c696e7cd44a71eae2211c95aee7a0b608df6cc61d08707e376e8c1c0349d430cc3136fdae86cf8b95972b8e392ffaef988bf738cb5b4c14f8e50124c03e96a522a4bcc5406610e9bee891277d7503c85cab3ac6b72181c7fc99261f4264c69163300cccc5c2390fd0d8b5a13b40b717563cfee31f47ca7986a7578d7608f8492c9c611e481a82a753ca0c5438c4305986ebbd3aa8e468a97911566df917f0087a1195c721714bfde129ff046b0680b6a969fc5b6a6ddc685101977a93290c898368232abf9615eb1612a96c286ea92e7b78b016cc57f156f8578d362bc8c59d86a0295e155c11521495c77ad40a9c4b50b6436d05d3c8e54944735a31b30ea38231ef1d341d1638911abfa2be151ba1bc67be08d09558b4556e4dc24fe1ee3a9576de495aade5cf2001868c5809412f9f7649ff1d2e235e462496c4cbb63663dd02bb547c9933ea07ecf008a910bb6c98dc9baef91e6e9d76279982c2f46af87333d6791c70dbc075f1120c39e75c686e6cc64645e1be824a4c505b57e8721cd5890cbb3c8af7de2dd15f99121a1624837eef74e9e68c3a95a3e94879071da5fb0ef374e09ec05ecfad9ed9bb7bc46644f0c907fd2a9cd90767835cda850d29138ef4a458e7de214f8261a19100bb2f39673047ddfceca40020f898a4b6e4e2cf5ff1eb079875cd135851e27013723a010a726caf1ca4ac4b6e6877ab56841bdcb66345b9794147d972d9d3ed90fdca315bd159a7bfdfc30e662ac880cc587f0a58ccad10b7a2922bc8ac76cf96981fb4900adeccff24317f6a4a02fadcc67a95b4b89f6c2ea5073a6addbfea656c71dd934bba4eefa3d96154337ad74fe0a61051615abcd3647ed11249f23e460c840932f75264da2d3e1d29af0a9ec1963cd696d3f7d5a3cf46dc8d276009bbe015562f12cc011750d80425ee0a42bfb813610b1cdd12c101b6845571a7b0aa6b8c36762b0a9aaff3856f2e124777ffd610e08cc927f47ad5b8f69dfb77ba08f261f97a7ce5a656b67e7c4da1c7521afb8238c995a9e40b2c78eb5193af3bb856209877fb8c14fbca70f6c5928a104bcbd16bb84045eb77574cf776945cba9887e4e7bb7d8f73cd0595741fb2258f4748634b4124fbb698d3e5cc4d019e7f01ae771736ed9272aae88ebd4b7450dabf4edeb67d2b78fb63806a584a20f54fd49c5601d34881871d1b236bd881427a4aa50b162d1a815a3db28d39022f1e4db851700bca79c748f6e528bc1d680cfa27c5177653262f6c5dc4408d23a029e702626022f5f15e01247c65d0d23171f26fd7bc982607af801d44f12989046c3b1aecb0139a25e82d2436062e52dae4f291f70a8ef363e5f93a2621882a8ad7e715d712e0adafc735ef27e39d73d2f704159cefec69a3bf712842f814d4ca3f24dee7760688ce21db2b8a839aa44e6d3c86ed8dae748972c2d585ecde93d367b694ed42b952ebe2cf8b39a4c401604ad8ec1410d772c744e6a852af77d02ce7f3e21470b881c5a97bd31730690de171ec0ce97fdd0d920fd9bb2d9e4341e59e7e02f2af69f25d8330d866cedcee366c4940b3783c21226c02341b7de2be2f46aa3a04180539727bd5bb140542486234578a3796b6dc08b49add9b4828db99d904f7a34656409f2d24097f874b653c80820929351e0ec9769abfdc61bdf5e4ef3e208bd83dade0a398d86b28b2ff03b796dfdfa0df0108182c9fc6667ff587bae4d0adf77b5da9e6de96dae1f29ffd088aa449f042de6db2d9248bf39483012457ce1a0a39372a625a4f47efea4fd51d8f959c5cc546ab6e23c6e322f54f2a584ff00c44ea9b93788211e61472046341f5eb234d650fe97a3e582643f963f5dd046b7fc8b3e6e5d22b8cfb02b04489fa0f7a442a39499c171ed8cfa2528a195459dce57e5c5933ee8de0502ab5e00c02452fc8bfd7c84db3cad790e7c6371c19888ab58ded2228ce276faaf2ad3aeff973ffb58d0b3ce4cde5bf870aaaff0c276d45b0fac4a816f93c792c25fd060750c9217a1c1bc89419155b47147528c30bbe6d439e1394aac15c2f03e3ad93f9c23451f1fbe766f64592bf5f04d681b61c9fea19e20fc748491aa2e0d4faee1b708e65574a35a9c1954b3e0cd2eac2edf7290867c23b13d19d2c6220376ca7a3a33f93912f25ed2dd5143a6de6fc375bcf04fd56e9cb8d7483f61a94e0ea865525cc481e76328531837af98697cf4b6ec88661294529f8e33e1318ff77ebd81adc706483851ee3436098405861203c94977e40ed138eacf57f31e9e678802d11f7de5c0a9c2f342408443f8c87e86806d1b4f9905d78f8a77e42ad37eb52e7fad81c9a76fa0dfc967fe8f0c0878e1a579ce4714dd65ed2b054431e0fc45462daba20a514d19d63b377649f39a509c44a3cfdaa28352633900ba21a6bbdaa77485a9d52c2c318d16488502b5108e022003448aa59da1135ee4ed6656a5873213816ac01398c7bd31f9ac3c229452dbfc5fc02dcef8adf9cd855e9d931592bc4e70ec82baff2d09e25be2cecb854e5d955b0fed3228c1f9244cca7bb6eda65ab2b2a9f2102736b3a6f9ea7b14b9070d1ccb46b94b67dad715cd241ccbd7f71055385a2da1f563a879b3498fdac643543a2b9065dcc7924b5f183d0df828ef58c05bba386eb33247ad165b3fb3302379f4ca98398ccc8ada3bff38db9ca8a8ea233cacf7a628e4733d2d091550abfef91cf311f8485f3aac9d2c1bdcf6dacb268dafa64542d416da96aad0be52df221294c0f4e5e2523137570cf8556776de6992e6a7593b21f988988a4e5188b875ee526591fc352094b51cc1c4b63f84802e55dd1197d3095fdb2c0b144653c64dd11ba27cd9d47b7fee3d8c10fb4974022d297821fced168ce15ab7d88c9ca9698a854b26d33657a548de9b9c71547d3bd2703d756b7a60be29f676b67c88b45ee41f7a3f1cef1bf51658457c4d0a8a73a5aa4e4b1a09ff6138db1cfff3852148c435fa0ee37d731756e9fd01b530281073e3bc0ab7efc034f046a27804f5590abb84fd995b5f76e41f36978ca30c09ef01127c1b266a49eb96570051800ce3c19545bc657caccd42a694666f97e956803730ca65f422a190a154b5fb327a5a7e2252a8440893c6a138c2f11cb163b9b515c3b9b62cc3b7c2d742e239cea7056889e8bdd2a79ebda6cb2b687cf1b0547653c6fa961bf5130588a4207e309b38826db7cf49ceaf12544d142fe4dc9e87dfd27aa17ecee64b67420a99f455c1b1b64e60683a76da944093c4d3bb340827abc95c2f9c14c0d9650e5fe9f42ec203cf79b0f07e04c70eaca5408a7a473aa3e78c93903c99d9002f7080e71d6bfe2475c4046c56a404829d90d74e2408af1786286ae5b35dccc1a520ebb85a231791f94fb04d38afd18e2ccd7f3e74624fe0afb71d5b6a9131dee166c26424bd6900499ef2c72312c366bf366a3bd4654f79cf3d0a20de00ce473ccd5611b6156e79f373a39632","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4bc7b1d9c8195306bad9cfddfcfe6bb8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
